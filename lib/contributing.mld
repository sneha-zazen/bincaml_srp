
{0 Contributing to bincaml}

This guide explains who to get started as a contributor.


{1 Standard Library}

All files should import the [util.common] library which contains extensions to
the OCaml standard library in the [containers] library, this is done by
depending on the [bincaml.util] library and putting at the top of the file.

[open Util.Common]

Use the documentation for [containers] as a reference before the standard
library api docs (although it should be a superset).

Note that this library replaces the unsafe polymorphic equality operator [(=)] with [Int.Infix.(=)],
for equality use the relevant monomorphic equality (e.g. for strings) [String.equal], or [String.Infix.(=)],
with the appropriate module in place of [String].

{{:https://c-cube.github.io/ocaml-containers/3.15/containers/index.html}containers library documentation}

We also depend on {{:https://c-cube.github.io/ocaml-containers/3.15/containers-data/index.html}containers-data}

For common tasks, check whether these implement the neccessary functionality:

E.g.:

- file IO: {! module:Containers.CCIO } module
- pretty printing: {! Containers_pp }
- sexpr reading/writing: {! Containers.Sexp }

We make as much use as possible of the following dependencies:

- {{:https://ocaml.org/p/ocamlgraph}backtracking/ocamlgraph} for graph algorithms
- {{:https://ocaml.org/p/fix}fpottier/fix} for fixpoints and memoisation
- {{:https://c-cube.github.io/ocaml-containers}c-cube/containers-data} for common persistent and imperative datastructures
- {{:https://c-cube.github.io/iter}c-cube/iter} efficient lazy iterators with
    minimal allocations, use these as an intermediate structure for composing transformations
    instead of {!Stdlib.List} or {!Stdlib.Seq}

Check whether these implement what you need before re-implementing standard algorithms.


{1 CookBook}

{2 Implementing Analyses }

1. An intraprocedural flow-insensitive single-pass analysis of an IR

Use {!Lang.Procedure.fold_blocks_topo_fwd} or {!Lang.Procedure.fold_blocks_topo_rev}.

To modify the procedure (returning a modified version, not modified in-place), use {! Lang.Procedure.map_blocks_topo_fwd}.

2. An intraprocedural flow-sensitive analysis of a non-ssa IR form with

Use the {{:https://backtracking.github.io/ocamlgraph/ocamlgraph/Graph/ChaoticIteration/index.html}Ocamlgraph
Bourdoncle chaotic iteration} fixed-point with widening.

The graph to use is {! Lang.Procedure.G} for forwards direction and {! Lang.Procedure.RevG} for
reverse direction.


{[
  Graph.ChaoticIteration.Make
    (Procedure.RevG)
    (struct
      open Procedure
      type vertex = RevG.E.vertex
      type edge = RevG.E.t
      type g = RevG.t
      type t = _
      let equal = _
      let join = _
      let widening a b = _

      let analyze (e : edge) data =
        match G.E.label e with Block b -> transfer_block_function d bata | _ -> data
    end)
  let analyse graph =
    let wto = Procedure.RevWTO.recursive_scc graph Procedure.Vert.Return
    in  LV.recurse graph wto
]}


3. For a simple forwards fixed-point over the call graph / block graph use {! module:Fix.Fixpoint }

See also {{:https://ocaml.org/p/fix/20250919/doc/fix/Fix/Fix/ForOrderedType/index.html}documentation for fix}

{[
module FixProp = Fix.Fix.ForOrderedType (Util.ID) (Domain:  sig
  type property = VS.t * VS.t
  val equal_property : property -> property -> bool
  val compare_property : property -> property -> int
  val bottom : VS.t * VS.t
  val equal : property -> property -> bool
  val compare : property -> property -> int
  val is_maximal : 'a -> bool
  val leq_join : property -> property -> property
  val to_string : property -> string
  val read : 'a * 'b -> 'a
  val written : 'a * 'b -> 'b
end)
(* transfer function for a node, e.g. id*)
let solve prog_proc =
  let equations (p : ID.t) (valuations : FixProp.valuation) =
      (* lookup block / proc id in prog_proc*)
      (* for successors, lookup their value in valuations *)
      _ in
  FixProp.lfp equations
]}


{2  Testing }

We have multiple kinds of testing

{4 Property tests}

Property tests use the using [quickcheck] library and {!QCheck_alcotest} driver.

- see [test/lang/expr_eval_qcheck.ml]
- These define generators ({!QCheck.Gen}) for values to randomly test inputs to a given function.

{4 Expect tests }

Expectation tests using [ppx_expect_nobase]: see [test/lang/expr_expect]. These
assert the printed output matches a specific string

Expect tests can be created by writing

{[
let%expect_test "example test" = print_endline "hello world"
]}

Then running [dune test] will fail the test with a diff of the expected output. [dune promote] can then be used to set the result to the expected value.

{v
$ dune test
File "test/lang/expr_eval_expect.ml", line 1, characters 0-0:
------ test/lang/expr_eval_expect.ml
++++++ test/lang/expr_eval_expect.ml.corrected
File "test/lang/expr_eval_expect.ml", line 67, characters 0-1:
 |
!|let%expect_test "example test" = print_endline "hello world";
!|  [%expect {| hello world |}]
$ dune promote
Promoting _build/default/test/lang/expr_eval_expect.ml.corrected to
  test/lang/expr_eval_expect.ml.
 v}

These should be used with care:

{ol
  {- Do not print too much information that will make the test fail with any unrelated change: be precise in what is under test }
  {- Ensure the output is human-readable and clear}
}

see also: {{:https://blog.janestreet.com/the-joy-of-expect-tests/}writeup on expect tests}


{4 cram tests through dune }

Example: see [test/lang/cram/]

These are expected output tests for a shell script. For example,

{v
Ignored explanatory test

    $ echo "expected output for shell line"

    expected output
v}


They have similar characteristics to expected output tests; prefer use the
shell to test some property of the cli rather than the fact it has a specific
output.

More details are available in the {{:https://dune.readthedocs.io/en/stable/reference/cram.html}dune manual}.


{1 OCaml }

Install instrsuctions can be found on {{:https://ocaml.org/install#linux_mac_bsd}ocaml.org}

Ocaml is a somewhat niche langauge so we spend a few words on why and how we use it.

Cheifly it comes down to

- library availability: OCaml gets a lot of use in the formal methods / program
  analysis fields so there is a large corpus of open source implementations we
  can draw on
- functional programming: OCaml is a functional language with a strong static type system and good type inference
- simplicity of the language: while a functional langauge, OCaml is strict
  (expressions are evaluated immediately), and lacks a type-class system in favour of the module
  system. These make OCaml code usually very transparent to understand (although sometimes more verbose).
- good tooling: the build system; dune, the langauge server, the compiler are
  all fast and interactive and well suited to the research-code use case.

If you want more evangelism you can find it {{:https://xvw.lol/en/articles/why-ocaml.html}here}.


{3 Learning OCaml }

We recommend the textbook to Cornell's CS3110 functional programming course,
which is available for free on their
{{:https://cs3110.github.io/textbook/ocaml_programming.pdf}website} and as
{{:https://cs3110.github.io/textbook/cover.html} pdf}.

Also consider reviewing the {{:https://ocaml.org/manual/5.3/index.html}OCaml manual}.

{4 OCaml code search }

opam package Search by type signature: {{:https://doc.sherlocode.com}https://doc.sherlocode.com}

full source search of opam reposotiry {{:https://sherlocode.com/}https://sherlocode.com/}


{3 Setting up ocaml: }

We recommend you install the language server and dev setup packages:

{v
opam install ocaml-lsp-server
opam install --deps-only --with-dev-setup .
v}

[--with-dev-setup] includes [ocamlformat], [odig], [sherlodoc] this is useful for documentation search.

Use the following to build and open the documentation page for an installed package, here [containers]:

{v
odig doc containers
v}


{2  Repeating Module Interfaces }

It is good practice to hide implementations by interfaces, however in practice this often requires
a significant amount of code rewriting to define the module and its interface separately.
Some tricks can be used to simplify this process.

The following post describes a trick to reduce this duplication: {{:https://www.craigfe.io/posts/the-intf-trick}https://www.craigfe.io/posts/the-intf-trick}.

The following trick can also be used to write some code in a module that is not included in the outer module:

{[
open struct
 type t = int
  let (v:t) = v + 1
end
]}

