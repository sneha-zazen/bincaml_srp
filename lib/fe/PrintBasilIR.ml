(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)



let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let prtBVTYPE _ (AbsBasilIR.BVTYPE (_,i)) : doc = render i


let prtINTTYPE _ (AbsBasilIR.INTTYPE (_,i)) : doc = render i


let prtBOOLTYPE _ (AbsBasilIR.BOOLTYPE (_,i)) : doc = render i


let prtBIdent _ (AbsBasilIR.BIdent (_,i)) : doc = render i


let prtLocalIdent _ (AbsBasilIR.LocalIdent (_,i)) : doc = render i


let prtGlobalIdent _ (AbsBasilIR.GlobalIdent (_,i)) : doc = render i


let prtBlockIdent _ (AbsBasilIR.BlockIdent (_,i)) : doc = render i
let rec prtBlockIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlockIdent 0 x])
  | (_,x::xs) -> (concatD [prtBlockIdent 0 x ; render "," ; prtBlockIdentListBNFC 0 xs])

let prtProcIdent _ (AbsBasilIR.ProcIdent (_,i)) : doc = render i


let prtBeginList _ (AbsBasilIR.BeginList (_,i)) : doc = render i


let prtEndList _ (AbsBasilIR.EndList (_,i)) : doc = render i


let prtBeginRec _ (AbsBasilIR.BeginRec (_,i)) : doc = render i


let prtEndRec _ (AbsBasilIR.EndRec (_,i)) : doc = render i


let prtLambdaSep _ (AbsBasilIR.LambdaSep i) : doc = render i


let prtStr _ (AbsBasilIR.Str i) : doc = render i


let prtIntegerHex _ (AbsBasilIR.IntegerHex (_,i)) : doc = render i


let prtIntegerDec _ (AbsBasilIR.IntegerDec (_,i)) : doc = render i



let rec prtModuleT (i:int) (e : AbsBasilIR.moduleT) : doc = match e with
       AbsBasilIR.Module1 decls -> prPrec i 0 (concatD [prtDeclListBNFC 0 decls])


and prtSemicolons (i:int) (e : AbsBasilIR.semicolons) : doc = match e with
       AbsBasilIR.Semicolons_Empty  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.Semicolons_Some semicolons -> prPrec i 0 (concatD [prtSemicolons 0 semicolons ; render ";"])


and prtDecl (i:int) (e : AbsBasilIR.decl) : doc = match e with
       AbsBasilIR.Decl_Axiom (attribset, expr) -> prPrec i 0 (concatD [render "axiom" ; prtAttribSet 0 attribset ; prtExpr 0 expr])
  |    AbsBasilIR.Decl_SharedMem (globalident, type_) -> prPrec i 0 (concatD [render "memory" ; render "shared" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.Decl_UnsharedMem (globalident, type_) -> prPrec i 0 (concatD [render "memory" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.Decl_Var (globalident, type_) -> prPrec i 0 (concatD [render "var" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.Decl_UninterpFun (attribset, globalident, types, type_) -> prPrec i 0 (concatD [render "declare-fun" ; prtAttribSet 0 attribset ; prtGlobalIdent 0 globalident ; render ":" ; render "(" ; prtTypeTListBNFC 0 types ; render ")" ; render "->" ; prtTypeT 0 type_])
  |    AbsBasilIR.Decl_Fun (attribset, globalident, paramss, type_, expr) -> prPrec i 0 (concatD [render "define-fun" ; prtAttribSet 0 attribset ; prtGlobalIdent 0 globalident ; render "(" ; prtParamsListBNFC 0 paramss ; render ")" ; render "->" ; prtTypeT 0 type_ ; render "=" ; prtExpr 0 expr])
  |    AbsBasilIR.Decl_ProgEmpty (procident, attribset) -> prPrec i 0 (concatD [render "prog" ; render "entry" ; prtProcIdent 0 procident ; prtAttribSet 0 attribset])
  |    AbsBasilIR.Decl_ProgWithSpec (procident, attribset, beginlist, progspecs, endlist) -> prPrec i 0 (concatD [render "prog" ; render "entry" ; prtProcIdent 0 procident ; prtAttribSet 0 attribset ; prtBeginList 0 beginlist ; prtProgSpecListBNFC 0 progspecs ; prtEndList 0 endlist])
  |    AbsBasilIR.Decl_Proc (procident, paramss1, paramss2, attribset, funspecs, procdef) -> prPrec i 0 (concatD [render "proc" ; prtProcIdent 0 procident ; render "(" ; prtParamsListBNFC 0 paramss1 ; render ")" ; render "->" ; render "(" ; prtParamsListBNFC 0 paramss2 ; render ")" ; prtAttribSet 0 attribset ; prtFunSpecListBNFC 0 funspecs ; prtProcDef 0 procdef])

and prtDeclListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtDecl 0 x ; render ";" ; prtDeclListBNFC 0 xs])
and prtProcDef (i:int) (e : AbsBasilIR.procDef) : doc = match e with
       AbsBasilIR.ProcDef_Empty  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.ProcDef_Some (beginlist, blocks, endlist) -> prPrec i 0 (concatD [prtBeginList 0 beginlist ; prtBlockListBNFC 0 blocks ; prtEndList 0 endlist])


and prtIntType (i:int) (e : AbsBasilIR.intType) : doc = match e with
       AbsBasilIR.IntType1 inttype -> prPrec i 0 (concatD [prtINTTYPE 0 inttype])


and prtBoolType (i:int) (e : AbsBasilIR.boolType) : doc = match e with
       AbsBasilIR.BoolType1 booltype -> prPrec i 0 (concatD [prtBOOLTYPE 0 booltype])


and prtMapType (i:int) (e : AbsBasilIR.mapType) : doc = match e with
       AbsBasilIR.MapType1 (type_1, type_2) -> prPrec i 0 (concatD [render "(" ; prtTypeT 0 type_1 ; render "->" ; prtTypeT 0 type_2 ; render ")"])


and prtBVType (i:int) (e : AbsBasilIR.bVType) : doc = match e with
       AbsBasilIR.BVType1 bvtype -> prPrec i 0 (concatD [prtBVTYPE 0 bvtype])


and prtTypeT (i:int) (e : AbsBasilIR.typeT) : doc = match e with
       AbsBasilIR.TypeIntType inttype -> prPrec i 0 (concatD [prtIntType 0 inttype])
  |    AbsBasilIR.TypeBoolType booltype -> prPrec i 0 (concatD [prtBoolType 0 booltype])
  |    AbsBasilIR.TypeMapType maptype -> prPrec i 0 (concatD [prtMapType 0 maptype])
  |    AbsBasilIR.TypeBVType bvtype -> prPrec i 0 (concatD [prtBVType 0 bvtype])

and prtTypeTListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtTypeT 0 x])
  | (_,x::xs) -> (concatD [prtTypeT 0 x ; render "," ; prtTypeTListBNFC 0 xs])
and prtIntVal (i:int) (e : AbsBasilIR.intVal) : doc = match e with
       AbsBasilIR.IntVal_Hex integerhex -> prPrec i 0 (concatD [prtIntegerHex 0 integerhex])
  |    AbsBasilIR.IntVal_Dec integerdec -> prPrec i 0 (concatD [prtIntegerDec 0 integerdec])


and prtBVVal (i:int) (e : AbsBasilIR.bVVal) : doc = match e with
       AbsBasilIR.BVVal1 (intval, bvtype) -> prPrec i 0 (concatD [prtIntVal 0 intval ; render ":" ; prtBVType 0 bvtype])


and prtEndian (i:int) (e : AbsBasilIR.endian) : doc = match e with
       AbsBasilIR.Endian_Little  -> prPrec i 0 (concatD [render "le"])
  |    AbsBasilIR.Endian_Big  -> prPrec i 0 (concatD [render "be"])


and prtAssignment (i:int) (e : AbsBasilIR.assignment) : doc = match e with
       AbsBasilIR.Assignment1 (lvar, expr) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; prtExpr 0 expr])

and prtAssignmentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAssignment 0 x])
  | (_,x::xs) -> (concatD [prtAssignment 0 x ; render "," ; prtAssignmentListBNFC 0 xs])
and prtStmt (i:int) (e : AbsBasilIR.stmt) : doc = match e with
       AbsBasilIR.Stmt_Nop  -> prPrec i 0 (concatD [render "nop"])
  |    AbsBasilIR.Stmt_SingleAssign assignment -> prPrec i 0 (concatD [prtAssignment 0 assignment])
  |    AbsBasilIR.Stmt_MultiAssign assignments -> prPrec i 0 (concatD [render "(" ; prtAssignmentListBNFC 0 assignments ; render ")"])
  |    AbsBasilIR.Stmt_Load (lvar, endian, globalident, expr, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr ; prtIntVal 0 intval])
  |    AbsBasilIR.Stmt_Store (endian, globalident, expr1, expr2, intval) -> prPrec i 0 (concatD [render "store" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr1 ; prtExpr 0 expr2 ; prtIntVal 0 intval])
  |    AbsBasilIR.Stmt_Load_Var (lvar, endian, var, expr, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtVar 0 var ; prtExpr 0 expr ; prtIntVal 0 intval])
  |    AbsBasilIR.Stmt_Store_Var (lvar, endian, var, expr1, expr2, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "store" ; prtEndian 0 endian ; prtVar 0 var ; prtExpr 0 expr1 ; prtExpr 0 expr2 ; prtIntVal 0 intval])
  |    AbsBasilIR.Stmt_DirectCall (lvars, procident, callparams) -> prPrec i 0 (concatD [prtLVars 0 lvars ; render "call" ; prtProcIdent 0 procident ; render "(" ; prtCallParams 0 callparams ; render ")"])
  |    AbsBasilIR.Stmt_IndirectCall expr -> prPrec i 0 (concatD [render "indirect" ; render "call" ; prtExpr 0 expr])
  |    AbsBasilIR.Stmt_Assume expr -> prPrec i 0 (concatD [render "assume" ; prtExpr 0 expr])
  |    AbsBasilIR.Stmt_Guard expr -> prPrec i 0 (concatD [render "guard" ; prtExpr 0 expr])
  |    AbsBasilIR.Stmt_Assert expr -> prPrec i 0 (concatD [render "assert" ; prtExpr 0 expr])


and prtLocalVar (i:int) (e : AbsBasilIR.localVar) : doc = match e with
       AbsBasilIR.LocalVar1 (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtLocalVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLocalVar 0 x])
  | (_,x::xs) -> (concatD [prtLocalVar 0 x ; render "," ; prtLocalVarListBNFC 0 xs])
and prtGlobalVar (i:int) (e : AbsBasilIR.globalVar) : doc = match e with
       AbsBasilIR.GlobalVar1 (globalident, type_) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])


and prtVar (i:int) (e : AbsBasilIR.var) : doc = match e with
       AbsBasilIR.VarLocalVar localvar -> prPrec i 0 (concatD [prtLocalVar 0 localvar])
  |    AbsBasilIR.VarGlobalVar globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])


and prtNamedCallReturn (i:int) (e : AbsBasilIR.namedCallReturn) : doc = match e with
       AbsBasilIR.NamedCallReturn1 (lvar, localident) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render "=" ; prtLocalIdent 0 localident])

and prtNamedCallReturnListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtNamedCallReturn 0 x])
  | (_,x::xs) -> (concatD [prtNamedCallReturn 0 x ; render "," ; prtNamedCallReturnListBNFC 0 xs])
and prtLVars (i:int) (e : AbsBasilIR.lVars) : doc = match e with
       AbsBasilIR.LVars_Empty  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.LVars_LocalList localvars -> prPrec i 0 (concatD [render "var" ; render "(" ; prtLocalVarListBNFC 0 localvars ; render ")" ; render ":="])
  |    AbsBasilIR.LVars_List lvars -> prPrec i 0 (concatD [render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":="])
  |    AbsBasilIR.NamedLVars_List namedcallreturns -> prPrec i 0 (concatD [render "(" ; prtNamedCallReturnListBNFC 0 namedcallreturns ; render ")" ; render ":="])


and prtNamedCallArg (i:int) (e : AbsBasilIR.namedCallArg) : doc = match e with
       AbsBasilIR.NamedCallArg1 (localident, expr) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render "=" ; prtExpr 0 expr])

and prtNamedCallArgListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtNamedCallArg 0 x])
  | (_,x::xs) -> (concatD [prtNamedCallArg 0 x ; render "," ; prtNamedCallArgListBNFC 0 xs])
and prtCallParams (i:int) (e : AbsBasilIR.callParams) : doc = match e with
       AbsBasilIR.CallParams_Exprs exprs -> prPrec i 0 (concatD [prtExprListBNFC 0 exprs])
  |    AbsBasilIR.CallParams_Named namedcallargs -> prPrec i 0 (concatD [prtNamedCallArgListBNFC 0 namedcallargs])


and prtJump (i:int) (e : AbsBasilIR.jump) : doc = match e with
       AbsBasilIR.Jump_GoTo blockidents -> prPrec i 0 (concatD [render "goto" ; render "(" ; prtBlockIdentListBNFC 0 blockidents ; render ")"])
  |    AbsBasilIR.Jump_Unreachable  -> prPrec i 0 (concatD [render "unreachable"])
  |    AbsBasilIR.Jump_Return exprs -> prPrec i 0 (concatD [render "return" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.Jump_ProcReturn  -> prPrec i 0 (concatD [render "return"])


and prtLVar (i:int) (e : AbsBasilIR.lVar) : doc = match e with
       AbsBasilIR.LVar_Local localvar -> prPrec i 0 (concatD [render "var" ; prtLocalVar 0 localvar])
  |    AbsBasilIR.LVar_Global globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])

and prtLVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLVar 0 x])
  | (_,x::xs) -> (concatD [prtLVar 0 x ; render "," ; prtLVarListBNFC 0 xs])
and prtStmtWithAttrib (i:int) (e : AbsBasilIR.stmtWithAttrib) : doc = match e with
       AbsBasilIR.StmtWithAttrib1 (stmt, attribset) -> prPrec i 0 (concatD [prtStmt 0 stmt ; prtAttribSet 0 attribset])

and prtStmtWithAttribListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtStmtWithAttrib 0 x ; render ";" ; prtStmtWithAttribListBNFC 0 xs])
and prtJumpWithAttrib (i:int) (e : AbsBasilIR.jumpWithAttrib) : doc = match e with
       AbsBasilIR.JumpWithAttrib1 (jump, attribset) -> prPrec i 0 (concatD [prtJump 0 jump ; prtAttribSet 0 attribset])


and prtPhiExpr (i:int) (e : AbsBasilIR.phiExpr) : doc = match e with
       AbsBasilIR.PhiExpr1 (blockident, var) -> prPrec i 0 (concatD [prtBlockIdent 0 blockident ; render "->" ; prtVar 0 var])

and prtPhiExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtPhiExpr 0 x])
  | (_,x::xs) -> (concatD [prtPhiExpr 0 x ; render "," ; prtPhiExprListBNFC 0 xs])
and prtPhiAssign (i:int) (e : AbsBasilIR.phiAssign) : doc = match e with
       AbsBasilIR.PhiAssign1 (lvar, phiexprs) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "phi" ; render "(" ; prtPhiExprListBNFC 0 phiexprs ; render ")"])

and prtPhiAssignListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtPhiAssign 0 x])
  | (_,x::xs) -> (concatD [prtPhiAssign 0 x ; render "," ; prtPhiAssignListBNFC 0 xs])
and prtBlock (i:int) (e : AbsBasilIR.block) : doc = match e with
       AbsBasilIR.Block_NoPhi (blockident, attribset, beginlist, stmtwithattribs, jumpwithattrib, endlist) -> prPrec i 0 (concatD [render "block" ; prtBlockIdent 0 blockident ; prtAttribSet 0 attribset ; prtBeginList 0 beginlist ; prtStmtWithAttribListBNFC 0 stmtwithattribs ; prtJumpWithAttrib 0 jumpwithattrib ; render ";" ; prtEndList 0 endlist])
  |    AbsBasilIR.Block_Phi (blockident, attribset, beginlist, phiassigns, stmtwithattribs, jumpwithattrib, endlist) -> prPrec i 0 (concatD [render "block" ; prtBlockIdent 0 blockident ; prtAttribSet 0 attribset ; prtBeginList 0 beginlist ; render "(" ; prtPhiAssignListBNFC 0 phiassigns ; render ")" ; render ";" ; prtStmtWithAttribListBNFC 0 stmtwithattribs ; prtJumpWithAttrib 0 jumpwithattrib ; render ";" ; prtEndList 0 endlist])

and prtBlockListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlock 0 x])
  | (_,x::xs) -> (concatD [prtBlock 0 x ; render ";" ; prtBlockListBNFC 0 xs])
and prtAttrKeyValue (i:int) (e : AbsBasilIR.attrKeyValue) : doc = match e with
       AbsBasilIR.AttrKeyValue1 (bident, attr) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtAttr 0 attr])

and prtAttrKeyValueListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAttrKeyValue 0 x])
  | (_,x::xs) -> (concatD [prtAttrKeyValue 0 x ; render ";" ; prtAttrKeyValueListBNFC 0 xs])
and prtAttribSet (i:int) (e : AbsBasilIR.attribSet) : doc = match e with
       AbsBasilIR.AttribSet_Some (beginrec, attrkeyvalues, semicolons, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtAttrKeyValueListBNFC 0 attrkeyvalues ; prtSemicolons 0 semicolons ; prtEndRec 0 endrec])
  |    AbsBasilIR.AttribSet_Empty  -> prPrec i 0 (concatD [])


and prtAttr (i:int) (e : AbsBasilIR.attr) : doc = match e with
       AbsBasilIR.Attr_Map (beginrec, attrkeyvalues, semicolons, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtAttrKeyValueListBNFC 0 attrkeyvalues ; prtSemicolons 0 semicolons ; prtEndRec 0 endrec])
  |    AbsBasilIR.Attr_List (beginlist, attrs, endlist) -> prPrec i 0 (concatD [prtBeginList 0 beginlist ; prtAttrListBNFC 0 attrs ; prtEndList 0 endlist])
  |    AbsBasilIR.Attr_Lit value -> prPrec i 0 (concatD [prtValue 0 value])
  |    AbsBasilIR.Attr_Str str -> prPrec i 0 (concatD [prtStr 0 str])

and prtAttrListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAttr 0 x])
  | (_,x::xs) -> (concatD [prtAttr 0 x ; render ";" ; prtAttrListBNFC 0 xs])
and prtParams (i:int) (e : AbsBasilIR.params) : doc = match e with
       AbsBasilIR.Params1 (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtParamsListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtParams 0 x])
  | (_,x::xs) -> (concatD [prtParams 0 x ; render "," ; prtParamsListBNFC 0 xs])
and prtValue (i:int) (e : AbsBasilIR.value) : doc = match e with
       AbsBasilIR.Value_BV bvval -> prPrec i 0 (concatD [prtBVVal 0 bvval])
  |    AbsBasilIR.Value_Int intval -> prPrec i 0 (concatD [prtIntVal 0 intval])
  |    AbsBasilIR.Value_True  -> prPrec i 0 (concatD [render "true"])
  |    AbsBasilIR.Value_False  -> prPrec i 0 (concatD [render "false"])


and prtExpr (i:int) (e : AbsBasilIR.expr) : doc = match e with
       AbsBasilIR.Expr_Literal value -> prPrec i 0 (concatD [prtValue 0 value])
  |    AbsBasilIR.Expr_Local localvar -> prPrec i 0 (concatD [prtLocalVar 0 localvar])
  |    AbsBasilIR.Expr_Global globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])
  |    AbsBasilIR.Expr_Forall lambdadef -> prPrec i 0 (concatD [render "forall" ; prtLambdaDef 0 lambdadef])
  |    AbsBasilIR.Expr_Exists lambdadef -> prPrec i 0 (concatD [render "exists" ; prtLambdaDef 0 lambdadef])
  |    AbsBasilIR.Expr_Old expr -> prPrec i 0 (concatD [render "old" ; render "(" ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Expr_FunctionOp (globalident, exprs) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.Expr_Binary (binop, expr1, expr2) -> prPrec i 0 (concatD [prtBinOp 0 binop ; render "(" ; prtExpr 0 expr1 ; render "," ; prtExpr 0 expr2 ; render ")"])
  |    AbsBasilIR.Expr_Assoc (boolbinop, exprs) -> prPrec i 0 (concatD [prtBoolBinOp 0 boolbinop ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.Expr_Unary (unop, expr) -> prPrec i 0 (concatD [prtUnOp 0 unop ; render "(" ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Expr_ZeroExtend (intval, expr) -> prPrec i 0 (concatD [render "zero_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Expr_SignExtend (intval, expr) -> prPrec i 0 (concatD [render "sign_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Expr_Extract (intval1, intval2, expr) -> prPrec i 0 (concatD [render "extract" ; render "(" ; prtIntVal 0 intval1 ; render "," ; prtIntVal 0 intval2 ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Expr_Concat exprs -> prPrec i 0 (concatD [render "bvconcat" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])

and prtExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
and prtLambdaDef (i:int) (e : AbsBasilIR.lambdaDef) : doc = match e with
       AbsBasilIR.LambdaDef1 (localvars, lambdasep, expr) -> prPrec i 0 (concatD [render "(" ; prtLocalVarListBNFC 0 localvars ; render ")" ; prtLambdaSep 0 lambdasep ; prtExpr 0 expr])


and prtBinOp (i:int) (e : AbsBasilIR.binOp) : doc = match e with
       AbsBasilIR.BinOpBVBinOp bvbinop -> prPrec i 0 (concatD [prtBVBinOp 0 bvbinop])
  |    AbsBasilIR.BinOpBVLogicalBinOp bvlogicalbinop -> prPrec i 0 (concatD [prtBVLogicalBinOp 0 bvlogicalbinop])
  |    AbsBasilIR.BinOpBoolBinOp boolbinop -> prPrec i 0 (concatD [prtBoolBinOp 0 boolbinop])
  |    AbsBasilIR.BinOpIntLogicalBinOp intlogicalbinop -> prPrec i 0 (concatD [prtIntLogicalBinOp 0 intlogicalbinop])
  |    AbsBasilIR.BinOpIntBinOp intbinop -> prPrec i 0 (concatD [prtIntBinOp 0 intbinop])
  |    AbsBasilIR.BinOpEqOp eqop -> prPrec i 0 (concatD [prtEqOp 0 eqop])


and prtUnOp (i:int) (e : AbsBasilIR.unOp) : doc = match e with
       AbsBasilIR.UnOpBVUnOp bvunop -> prPrec i 0 (concatD [prtBVUnOp 0 bvunop])
  |    AbsBasilIR.UnOp_boolnot  -> prPrec i 0 (concatD [render "boolnot"])
  |    AbsBasilIR.UnOp_intneg  -> prPrec i 0 (concatD [render "intneg"])
  |    AbsBasilIR.UnOp_booltobv1  -> prPrec i 0 (concatD [render "booltobv1"])


and prtEqOp (i:int) (e : AbsBasilIR.eqOp) : doc = match e with
       AbsBasilIR.EqOp_eq  -> prPrec i 0 (concatD [render "eq"])
  |    AbsBasilIR.EqOp_neq  -> prPrec i 0 (concatD [render "neq"])


and prtBVUnOp (i:int) (e : AbsBasilIR.bVUnOp) : doc = match e with
       AbsBasilIR.BVUnOp_bvnot  -> prPrec i 0 (concatD [render "bvnot"])
  |    AbsBasilIR.BVUnOp_bvneg  -> prPrec i 0 (concatD [render "bvneg"])


and prtBVBinOp (i:int) (e : AbsBasilIR.bVBinOp) : doc = match e with
       AbsBasilIR.BVBinOp_bvand  -> prPrec i 0 (concatD [render "bvand"])
  |    AbsBasilIR.BVBinOp_bvor  -> prPrec i 0 (concatD [render "bvor"])
  |    AbsBasilIR.BVBinOp_bvadd  -> prPrec i 0 (concatD [render "bvadd"])
  |    AbsBasilIR.BVBinOp_bvmul  -> prPrec i 0 (concatD [render "bvmul"])
  |    AbsBasilIR.BVBinOp_bvudiv  -> prPrec i 0 (concatD [render "bvudiv"])
  |    AbsBasilIR.BVBinOp_bvurem  -> prPrec i 0 (concatD [render "bvurem"])
  |    AbsBasilIR.BVBinOp_bvshl  -> prPrec i 0 (concatD [render "bvshl"])
  |    AbsBasilIR.BVBinOp_bvlshr  -> prPrec i 0 (concatD [render "bvlshr"])
  |    AbsBasilIR.BVBinOp_bvnand  -> prPrec i 0 (concatD [render "bvnand"])
  |    AbsBasilIR.BVBinOp_bvnor  -> prPrec i 0 (concatD [render "bvnor"])
  |    AbsBasilIR.BVBinOp_bvxor  -> prPrec i 0 (concatD [render "bvxor"])
  |    AbsBasilIR.BVBinOp_bvxnor  -> prPrec i 0 (concatD [render "bvxnor"])
  |    AbsBasilIR.BVBinOp_bvcomp  -> prPrec i 0 (concatD [render "bvcomp"])
  |    AbsBasilIR.BVBinOp_bvsub  -> prPrec i 0 (concatD [render "bvsub"])
  |    AbsBasilIR.BVBinOp_bvsdiv  -> prPrec i 0 (concatD [render "bvsdiv"])
  |    AbsBasilIR.BVBinOp_bvsrem  -> prPrec i 0 (concatD [render "bvsrem"])
  |    AbsBasilIR.BVBinOp_bvsmod  -> prPrec i 0 (concatD [render "bvsmod"])
  |    AbsBasilIR.BVBinOp_bvashr  -> prPrec i 0 (concatD [render "bvashr"])


and prtBVLogicalBinOp (i:int) (e : AbsBasilIR.bVLogicalBinOp) : doc = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> prPrec i 0 (concatD [render "bvule"])
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> prPrec i 0 (concatD [render "bvugt"])
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> prPrec i 0 (concatD [render "bvuge"])
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> prPrec i 0 (concatD [render "bvult"])
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> prPrec i 0 (concatD [render "bvslt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> prPrec i 0 (concatD [render "bvsle"])
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> prPrec i 0 (concatD [render "bvsgt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> prPrec i 0 (concatD [render "bvsge"])


and prtIntBinOp (i:int) (e : AbsBasilIR.intBinOp) : doc = match e with
       AbsBasilIR.IntBinOp_intadd  -> prPrec i 0 (concatD [render "intadd"])
  |    AbsBasilIR.IntBinOp_intmul  -> prPrec i 0 (concatD [render "intmul"])
  |    AbsBasilIR.IntBinOp_intsub  -> prPrec i 0 (concatD [render "intsub"])
  |    AbsBasilIR.IntBinOp_intdiv  -> prPrec i 0 (concatD [render "intdiv"])
  |    AbsBasilIR.IntBinOp_intmod  -> prPrec i 0 (concatD [render "intmod"])


and prtIntLogicalBinOp (i:int) (e : AbsBasilIR.intLogicalBinOp) : doc = match e with
       AbsBasilIR.IntLogicalBinOp_intlt  -> prPrec i 0 (concatD [render "intlt"])
  |    AbsBasilIR.IntLogicalBinOp_intle  -> prPrec i 0 (concatD [render "intle"])
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> prPrec i 0 (concatD [render "intgt"])
  |    AbsBasilIR.IntLogicalBinOp_intge  -> prPrec i 0 (concatD [render "intge"])


and prtBoolBinOp (i:int) (e : AbsBasilIR.boolBinOp) : doc = match e with
       AbsBasilIR.BoolBinOp_booland  -> prPrec i 0 (concatD [render "booland"])
  |    AbsBasilIR.BoolBinOp_boolor  -> prPrec i 0 (concatD [render "boolor"])
  |    AbsBasilIR.BoolBinOp_boolimplies  -> prPrec i 0 (concatD [render "boolimplies"])


and prtRequireTok (i:int) (e : AbsBasilIR.requireTok) : doc = match e with
       AbsBasilIR.RequireTok_require  -> prPrec i 0 (concatD [render "require"])
  |    AbsBasilIR.RequireTok_requires  -> prPrec i 0 (concatD [render "requires"])


and prtEnsureTok (i:int) (e : AbsBasilIR.ensureTok) : doc = match e with
       AbsBasilIR.EnsureTok_ensure  -> prPrec i 0 (concatD [render "ensure"])
  |    AbsBasilIR.EnsureTok_ensures  -> prPrec i 0 (concatD [render "ensures"])


and prtFunSpec (i:int) (e : AbsBasilIR.funSpec) : doc = match e with
       AbsBasilIR.FunSpec_Require (requiretok, expr) -> prPrec i 0 (concatD [prtRequireTok 0 requiretok ; prtExpr 0 expr])
  |    AbsBasilIR.FunSpec_Ensure (ensuretok, expr) -> prPrec i 0 (concatD [prtEnsureTok 0 ensuretok ; prtExpr 0 expr])
  |    AbsBasilIR.FunSpec_Invariant (blockident, expr) -> prPrec i 0 (concatD [render "invariant" ; prtBlockIdent 0 blockident ; prtExpr 0 expr])

and prtFunSpecListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtFunSpec 0 x ; render ";" ; prtFunSpecListBNFC 0 xs])
and prtProgSpec (i:int) (e : AbsBasilIR.progSpec) : doc = match e with
       AbsBasilIR.ProgSpec_Rely expr -> prPrec i 0 (concatD [render "rely" ; prtExpr 0 expr])
  |    AbsBasilIR.ProgSpec_Guarantee expr -> prPrec i 0 (concatD [render "guarantee" ; prtExpr 0 expr])

and prtProgSpecListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtProgSpec 0 x ; render ";" ; prtProgSpecListBNFC 0 xs])

