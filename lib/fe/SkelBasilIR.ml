(* File generated by the BNF Converter (bnfc 2.9.5). *)

module SkelBasilIR = struct

open AbsBasilIR

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transBVTYPE (x : bVTYPE) : result = match x with
    BVTYPE string -> failure x


and transINTTYPE (x : iNTTYPE) : result = match x with
    INTTYPE string -> failure x


and transBOOLTYPE (x : bOOLTYPE) : result = match x with
    BOOLTYPE string -> failure x


and transBIdent (x : bIdent) : result = match x with
    BIdent string -> failure x


and transLocalIdent (x : localIdent) : result = match x with
    LocalIdent string -> failure x


and transGlobalIdent (x : globalIdent) : result = match x with
    GlobalIdent string -> failure x


and transBlockIdent (x : blockIdent) : result = match x with
    BlockIdent string -> failure x


and transProcIdent (x : procIdent) : result = match x with
    ProcIdent string -> failure x


and transBeginList (x : beginList) : result = match x with
    BeginList string -> failure x


and transEndList (x : endList) : result = match x with
    EndList string -> failure x


and transBeginRec (x : beginRec) : result = match x with
    BeginRec string -> failure x


and transEndRec (x : endRec) : result = match x with
    EndRec string -> failure x


and transLambdaSep (x : lambdaSep) : result = match x with
    LambdaSep string -> failure x


and transStr (x : str) : result = match x with
    Str string -> failure x


and transIntegerHex (x : integerHex) : result = match x with
    IntegerHex string -> failure x


and transIntegerDec (x : integerDec) : result = match x with
    IntegerDec string -> failure x


and transModule (x : moduleT) : result = match x with
    Module1 decls -> failure x


and transSemicolons (x : semicolons) : result = match x with
    Semicolons_Empty  -> failure x
  | Semicolons_Some semicolons -> failure x


and transDecl (x : decl) : result = match x with
    Decl_Axiom (attribset, expr) -> failure x
  | Decl_SharedMem (globalident, type') -> failure x
  | Decl_UnsharedMem (globalident, type') -> failure x
  | Decl_Var (globalident, type') -> failure x
  | Decl_UninterpFun (attribset, globalident, types, type') -> failure x
  | Decl_Fun (attribset, globalident, paramss, type', expr) -> failure x
  | Decl_ProgEmpty (procident, attribset) -> failure x
  | Decl_ProgWithSpec (procident, attribset, beginlist, progspecs, endlist) -> failure x
  | Decl_Proc (procident, paramss0, paramss, attribset, funspecs, procdef) -> failure x


and transProcDef (x : procDef) : result = match x with
    ProcDef_Empty  -> failure x
  | ProcDef_Some (beginlist, blocks, endlist) -> failure x


and transIntType (x : intType) : result = match x with
    IntType1 inttype -> failure x


and transBoolType (x : boolType) : result = match x with
    BoolType1 booltype -> failure x


and transMapType (x : mapType) : result = match x with
    MapType1 (type'0, type') -> failure x


and transBVType (x : bVType) : result = match x with
    BVType1 bvtype -> failure x


and transType (x : typeT) : result = match x with
    TypeIntType inttype -> failure x
  | TypeBoolType booltype -> failure x
  | TypeMapType maptype -> failure x
  | TypeBVType bvtype -> failure x


and transIntVal (x : intVal) : result = match x with
    IntVal_Hex integerhex -> failure x
  | IntVal_Dec integerdec -> failure x


and transBVVal (x : bVVal) : result = match x with
    BVVal1 (intval, bvtype) -> failure x


and transEndian (x : endian) : result = match x with
    Endian_Little  -> failure x
  | Endian_Big  -> failure x


and transAssignment (x : assignment) : result = match x with
    Assignment1 (lvar, expr) -> failure x


and transStmt (x : stmt) : result = match x with
    Stmt_Nop  -> failure x
  | Stmt_SingleAssign assignment -> failure x
  | Stmt_MultiAssign assignments -> failure x
  | Stmt_Load (lvar, endian, globalident, expr, intval) -> failure x
  | Stmt_Store (endian, globalident, expr0, expr, intval) -> failure x
  | Stmt_Load_Var (lvar, endian, var, expr, intval) -> failure x
  | Stmt_Store_Var (lvar, endian, var, expr0, expr, intval) -> failure x
  | Stmt_DirectCall (lvars, procident, callparams) -> failure x
  | Stmt_IndirectCall expr -> failure x
  | Stmt_Assume expr -> failure x
  | Stmt_Guard expr -> failure x
  | Stmt_Assert expr -> failure x


and transLocalVar (x : localVar) : result = match x with
    LocalVar1 (localident, type') -> failure x


and transGlobalVar (x : globalVar) : result = match x with
    GlobalVar1 (globalident, type') -> failure x


and transVar (x : var) : result = match x with
    VarLocalVar localvar -> failure x
  | VarGlobalVar globalvar -> failure x


and transNamedCallReturn (x : namedCallReturn) : result = match x with
    NamedCallReturn1 (lvar, localident) -> failure x


and transLVars (x : lVars) : result = match x with
    LVars_Empty  -> failure x
  | LVars_LocalList localvars -> failure x
  | LVars_List lvars -> failure x
  | NamedLVars_List namedcallreturns -> failure x


and transNamedCallArg (x : namedCallArg) : result = match x with
    NamedCallArg1 (localident, expr) -> failure x


and transCallParams (x : callParams) : result = match x with
    CallParams_Exprs exprs -> failure x
  | CallParams_Named namedcallargs -> failure x


and transJump (x : jump) : result = match x with
    Jump_GoTo blockidents -> failure x
  | Jump_Unreachable  -> failure x
  | Jump_Return exprs -> failure x
  | Jump_ReturnNamedParams namedcallargs -> failure x


and transLVar (x : lVar) : result = match x with
    LVar_Local localvar -> failure x
  | LVar_Global globalvar -> failure x


and transStmtWithAttrib (x : stmtWithAttrib) : result = match x with
    StmtWithAttrib1 (stmt, attribset) -> failure x


and transJumpWithAttrib (x : jumpWithAttrib) : result = match x with
    JumpWithAttrib1 (jump, attribset) -> failure x


and transBlock (x : block) : result = match x with
    Block1 (blockident, attribset, beginlist, stmtwithattribs, jumpwithattrib, endlist) -> failure x


and transAttrKeyValue (x : attrKeyValue) : result = match x with
    AttrKeyValue1 (bident, attr) -> failure x


and transAttribSet (x : attribSet) : result = match x with
    AttribSet_Some (beginrec, attrkeyvalues, semicolons, endrec) -> failure x
  | AttribSet_Empty  -> failure x


and transAttr (x : attr) : result = match x with
    Attr_Map (beginrec, attrkeyvalues, semicolons, endrec) -> failure x
  | Attr_List (beginlist, attrs, endlist) -> failure x
  | Attr_Lit value -> failure x
  | Attr_Str str -> failure x


and transParams (x : params) : result = match x with
    Params1 (localident, type') -> failure x


and transValue (x : value) : result = match x with
    Value_BV bvval -> failure x
  | Value_Int intval -> failure x
  | Value_True  -> failure x
  | Value_False  -> failure x


and transExpr (x : expr) : result = match x with
    Expr_Literal value -> failure x
  | Expr_Local localvar -> failure x
  | Expr_Global globalvar -> failure x
  | Expr_Forall lambdadef -> failure x
  | Expr_Exists lambdadef -> failure x
  | Expr_Old expr -> failure x
  | Expr_FunctionOp (globalident, exprs) -> failure x
  | Expr_Binary (binop, expr0, expr) -> failure x
  | Expr_Assoc (boolbinop, exprs) -> failure x
  | Expr_Unary (unop, expr) -> failure x
  | Expr_ZeroExtend (intval, expr) -> failure x
  | Expr_SignExtend (intval, expr) -> failure x
  | Expr_Extract (intval0, intval, expr) -> failure x
  | Expr_Concat exprs -> failure x


and transLambdaDef (x : lambdaDef) : result = match x with
    LambdaDef1 (localvars, lambdasep, expr) -> failure x


and transBinOp (x : binOp) : result = match x with
    BinOpBVBinOp bvbinop -> failure x
  | BinOpBVLogicalBinOp bvlogicalbinop -> failure x
  | BinOpBoolBinOp boolbinop -> failure x
  | BinOpIntLogicalBinOp intlogicalbinop -> failure x
  | BinOpIntBinOp intbinop -> failure x
  | BinOpEqOp eqop -> failure x


and transUnOp (x : unOp) : result = match x with
    UnOpBVUnOp bvunop -> failure x
  | UnOp_boolnot  -> failure x
  | UnOp_intneg  -> failure x
  | UnOp_booltobv1  -> failure x


and transEqOp (x : eqOp) : result = match x with
    EqOp_eq  -> failure x
  | EqOp_neq  -> failure x


and transBVUnOp (x : bVUnOp) : result = match x with
    BVUnOp_bvnot  -> failure x
  | BVUnOp_bvneg  -> failure x


and transBVBinOp (x : bVBinOp) : result = match x with
    BVBinOp_bvand  -> failure x
  | BVBinOp_bvor  -> failure x
  | BVBinOp_bvadd  -> failure x
  | BVBinOp_bvmul  -> failure x
  | BVBinOp_bvudiv  -> failure x
  | BVBinOp_bvurem  -> failure x
  | BVBinOp_bvshl  -> failure x
  | BVBinOp_bvlshr  -> failure x
  | BVBinOp_bvnand  -> failure x
  | BVBinOp_bvnor  -> failure x
  | BVBinOp_bvxor  -> failure x
  | BVBinOp_bvxnor  -> failure x
  | BVBinOp_bvcomp  -> failure x
  | BVBinOp_bvsub  -> failure x
  | BVBinOp_bvsdiv  -> failure x
  | BVBinOp_bvsrem  -> failure x
  | BVBinOp_bvsmod  -> failure x
  | BVBinOp_bvashr  -> failure x


and transBVLogicalBinOp (x : bVLogicalBinOp) : result = match x with
    BVLogicalBinOp_bvule  -> failure x
  | BVLogicalBinOp_bvugt  -> failure x
  | BVLogicalBinOp_bvuge  -> failure x
  | BVLogicalBinOp_bvult  -> failure x
  | BVLogicalBinOp_bvslt  -> failure x
  | BVLogicalBinOp_bvsle  -> failure x
  | BVLogicalBinOp_bvsgt  -> failure x
  | BVLogicalBinOp_bvsge  -> failure x


and transIntBinOp (x : intBinOp) : result = match x with
    IntBinOp_intadd  -> failure x
  | IntBinOp_intmul  -> failure x
  | IntBinOp_intsub  -> failure x
  | IntBinOp_intdiv  -> failure x
  | IntBinOp_intmod  -> failure x


and transIntLogicalBinOp (x : intLogicalBinOp) : result = match x with
    IntLogicalBinOp_intlt  -> failure x
  | IntLogicalBinOp_intle  -> failure x
  | IntLogicalBinOp_intgt  -> failure x
  | IntLogicalBinOp_intge  -> failure x


and transBoolBinOp (x : boolBinOp) : result = match x with
    BoolBinOp_booland  -> failure x
  | BoolBinOp_boolor  -> failure x
  | BoolBinOp_boolimplies  -> failure x


and transRequireTok (x : requireTok) : result = match x with
    RequireTok_require  -> failure x
  | RequireTok_requires  -> failure x


and transEnsureTok (x : ensureTok) : result = match x with
    EnsureTok_ensure  -> failure x
  | EnsureTok_ensures  -> failure x


and transFunSpec (x : funSpec) : result = match x with
    FunSpec_Require (requiretok, expr) -> failure x
  | FunSpec_Ensure (ensuretok, expr) -> failure x
  | FunSpec_Invariant (blockident, expr) -> failure x


and transProgSpec (x : progSpec) : result = match x with
    ProgSpec_Rely expr -> failure x
  | ProgSpec_Guarantee expr -> failure x



end
