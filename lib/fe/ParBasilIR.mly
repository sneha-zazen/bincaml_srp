/* File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition for use with menhir */

%{
open AbsBasilIR
open Lexing
%}

%token KW_axiom KW_memory KW_shared KW_var KW_prog KW_entry KW_proc KW_le KW_be KW_nop KW_load KW_store KW_call KW_indirect KW_assume KW_guard KW_assert KW_goto KW_unreachable KW_return KW_block KW_true KW_false KW_forall KW_exists KW_old KW_boolnot KW_intneg KW_booltobv1 KW_zero_extend KW_sign_extend KW_extract KW_bvconcat KW_eq KW_neq KW_bvnot KW_bvneg KW_bvand KW_bvor KW_bvadd KW_bvmul KW_bvudiv KW_bvurem KW_bvshl KW_bvlshr KW_bvnand KW_bvnor KW_bvxor KW_bvxnor KW_bvcomp KW_bvsub KW_bvsdiv KW_bvsrem KW_bvsmod KW_bvashr KW_bvule KW_bvugt KW_bvuge KW_bvult KW_bvslt KW_bvsle KW_bvsgt KW_bvsge KW_intadd KW_intmul KW_intsub KW_intdiv KW_intmod KW_intlt KW_intle KW_intgt KW_intge KW_booland KW_boolor KW_boolimplies KW_require KW_requires KW_ensure KW_ensures KW_invariant KW_rely KW_guarantee

%token SYMB1 /* ; */
%token SYMB2 /* , */
%token SYMB3 /* : */
%token SYMB4 /* declare-fun */
%token SYMB5 /* ( */
%token SYMB6 /* ) */
%token SYMB7 /* -> */
%token SYMB8 /* define-fun */
%token SYMB9 /* = */
%token SYMB10 /* := */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String
%token <(int * int) * string> TOK_BVTYPE
%token <(int * int) * string> TOK_INTTYPE
%token <(int * int) * string> TOK_BOOLTYPE
%token <(int * int) * string> TOK_BIdent
%token <(int * int) * string> TOK_LocalIdent
%token <(int * int) * string> TOK_GlobalIdent
%token <(int * int) * string> TOK_BlockIdent
%token <(int * int) * string> TOK_ProcIdent
%token <(int * int) * string> TOK_BeginList
%token <(int * int) * string> TOK_EndList
%token <(int * int) * string> TOK_BeginRec
%token <(int * int) * string> TOK_EndRec
%token <string>               TOK_LambdaSep
%token <string>               TOK_Str
%token <(int * int) * string> TOK_IntegerHex
%token <(int * int) * string> TOK_IntegerDec

%start pModuleT pDecl_list pBlockIdent_list pSemicolons pDecl pTypeT_list pProcDef pIntType pBoolType pMapType pBVType pTypeT pExpr_list pIntVal pBVVal pEndian pAssignment pStmt pAssignment_list pLocalVar pGlobalVar pLocalVar_list pVar pNamedCallReturn pNamedCallReturn_list pLVars pNamedCallArg pNamedCallArg_list pCallParams pJump pLVar pLVar_list pBlock_list pStmtWithAttrib pStmtWithAttrib_list pJumpWithAttrib pBlock pAttrKeyValue pAttrKeyValue_list pAttribSet pAttr_list pAttr pParams pParams_list pValue pExpr pLambdaDef pBinOp pUnOp pEqOp pBVUnOp pBVBinOp pBVLogicalBinOp pIntBinOp pIntLogicalBinOp pBoolBinOp pRequireTok pEnsureTok pFunSpec pProgSpec pFunSpec_list pProgSpec_list
%type <AbsBasilIR.moduleT> pModuleT
%type <AbsBasilIR.decl list> pDecl_list
%type <AbsBasilIR.blockIdent list> pBlockIdent_list
%type <AbsBasilIR.semicolons> pSemicolons
%type <AbsBasilIR.decl> pDecl
%type <AbsBasilIR.typeT list> pTypeT_list
%type <AbsBasilIR.procDef> pProcDef
%type <AbsBasilIR.intType> pIntType
%type <AbsBasilIR.boolType> pBoolType
%type <AbsBasilIR.mapType> pMapType
%type <AbsBasilIR.bVType> pBVType
%type <AbsBasilIR.typeT> pTypeT
%type <AbsBasilIR.expr list> pExpr_list
%type <AbsBasilIR.intVal> pIntVal
%type <AbsBasilIR.bVVal> pBVVal
%type <AbsBasilIR.endian> pEndian
%type <AbsBasilIR.assignment> pAssignment
%type <AbsBasilIR.stmt> pStmt
%type <AbsBasilIR.assignment list> pAssignment_list
%type <AbsBasilIR.localVar> pLocalVar
%type <AbsBasilIR.globalVar> pGlobalVar
%type <AbsBasilIR.localVar list> pLocalVar_list
%type <AbsBasilIR.var> pVar
%type <AbsBasilIR.namedCallReturn> pNamedCallReturn
%type <AbsBasilIR.namedCallReturn list> pNamedCallReturn_list
%type <AbsBasilIR.lVars> pLVars
%type <AbsBasilIR.namedCallArg> pNamedCallArg
%type <AbsBasilIR.namedCallArg list> pNamedCallArg_list
%type <AbsBasilIR.callParams> pCallParams
%type <AbsBasilIR.jump> pJump
%type <AbsBasilIR.lVar> pLVar
%type <AbsBasilIR.lVar list> pLVar_list
%type <AbsBasilIR.block list> pBlock_list
%type <AbsBasilIR.stmtWithAttrib> pStmtWithAttrib
%type <AbsBasilIR.stmtWithAttrib list> pStmtWithAttrib_list
%type <AbsBasilIR.jumpWithAttrib> pJumpWithAttrib
%type <AbsBasilIR.block> pBlock
%type <AbsBasilIR.attrKeyValue> pAttrKeyValue
%type <AbsBasilIR.attrKeyValue list> pAttrKeyValue_list
%type <AbsBasilIR.attribSet> pAttribSet
%type <AbsBasilIR.attr list> pAttr_list
%type <AbsBasilIR.attr> pAttr
%type <AbsBasilIR.params> pParams
%type <AbsBasilIR.params list> pParams_list
%type <AbsBasilIR.value> pValue
%type <AbsBasilIR.expr> pExpr
%type <AbsBasilIR.lambdaDef> pLambdaDef
%type <AbsBasilIR.binOp> pBinOp
%type <AbsBasilIR.unOp> pUnOp
%type <AbsBasilIR.eqOp> pEqOp
%type <AbsBasilIR.bVUnOp> pBVUnOp
%type <AbsBasilIR.bVBinOp> pBVBinOp
%type <AbsBasilIR.bVLogicalBinOp> pBVLogicalBinOp
%type <AbsBasilIR.intBinOp> pIntBinOp
%type <AbsBasilIR.intLogicalBinOp> pIntLogicalBinOp
%type <AbsBasilIR.boolBinOp> pBoolBinOp
%type <AbsBasilIR.requireTok> pRequireTok
%type <AbsBasilIR.ensureTok> pEnsureTok
%type <AbsBasilIR.funSpec> pFunSpec
%type <AbsBasilIR.progSpec> pProgSpec
%type <AbsBasilIR.funSpec list> pFunSpec_list
%type <AbsBasilIR.progSpec list> pProgSpec_list

%type <AbsBasilIR.moduleT> moduleT
%type <AbsBasilIR.decl list> decl_list
%type <AbsBasilIR.blockIdent list> blockIdent_list
%type <AbsBasilIR.semicolons> semicolons
%type <AbsBasilIR.decl> decl
%type <AbsBasilIR.typeT list> typeT_list
%type <AbsBasilIR.procDef> procDef
%type <AbsBasilIR.intType> intType
%type <AbsBasilIR.boolType> boolType
%type <AbsBasilIR.mapType> mapType
%type <AbsBasilIR.bVType> bVType
%type <AbsBasilIR.typeT> typeT
%type <AbsBasilIR.expr list> expr_list
%type <AbsBasilIR.intVal> intVal
%type <AbsBasilIR.bVVal> bVVal
%type <AbsBasilIR.endian> endian
%type <AbsBasilIR.assignment> assignment
%type <AbsBasilIR.stmt> stmt
%type <AbsBasilIR.assignment list> assignment_list
%type <AbsBasilIR.localVar> localVar
%type <AbsBasilIR.globalVar> globalVar
%type <AbsBasilIR.localVar list> localVar_list
%type <AbsBasilIR.var> var
%type <AbsBasilIR.namedCallReturn> namedCallReturn
%type <AbsBasilIR.namedCallReturn list> namedCallReturn_list
%type <AbsBasilIR.lVars> lVars
%type <AbsBasilIR.namedCallArg> namedCallArg
%type <AbsBasilIR.namedCallArg list> namedCallArg_list
%type <AbsBasilIR.callParams> callParams
%type <AbsBasilIR.jump> jump
%type <AbsBasilIR.lVar> lVar
%type <AbsBasilIR.lVar list> lVar_list
%type <AbsBasilIR.block list> block_list
%type <AbsBasilIR.stmtWithAttrib> stmtWithAttrib
%type <AbsBasilIR.stmtWithAttrib list> stmtWithAttrib_list
%type <AbsBasilIR.jumpWithAttrib> jumpWithAttrib
%type <AbsBasilIR.block> block
%type <AbsBasilIR.attrKeyValue> attrKeyValue
%type <AbsBasilIR.attrKeyValue list> attrKeyValue_list
%type <AbsBasilIR.attribSet> attribSet
%type <AbsBasilIR.attr list> attr_list
%type <AbsBasilIR.attr> attr
%type <AbsBasilIR.params> params
%type <AbsBasilIR.params list> params_list
%type <AbsBasilIR.value> value
%type <AbsBasilIR.expr> expr
%type <AbsBasilIR.lambdaDef> lambdaDef
%type <AbsBasilIR.binOp> binOp
%type <AbsBasilIR.unOp> unOp
%type <AbsBasilIR.eqOp> eqOp
%type <AbsBasilIR.bVUnOp> bVUnOp
%type <AbsBasilIR.bVBinOp> bVBinOp
%type <AbsBasilIR.bVLogicalBinOp> bVLogicalBinOp
%type <AbsBasilIR.intBinOp> intBinOp
%type <AbsBasilIR.intLogicalBinOp> intLogicalBinOp
%type <AbsBasilIR.boolBinOp> boolBinOp
%type <AbsBasilIR.requireTok> requireTok
%type <AbsBasilIR.ensureTok> ensureTok
%type <AbsBasilIR.funSpec> funSpec
%type <AbsBasilIR.progSpec> progSpec
%type <AbsBasilIR.funSpec list> funSpec_list
%type <AbsBasilIR.progSpec list> progSpec_list

%type <AbsBasilIR.bVTYPE> bVTYPE
%type <AbsBasilIR.iNTTYPE> iNTTYPE
%type <AbsBasilIR.bOOLTYPE> bOOLTYPE
%type <AbsBasilIR.bIdent> bIdent
%type <AbsBasilIR.localIdent> localIdent
%type <AbsBasilIR.globalIdent> globalIdent
%type <AbsBasilIR.blockIdent> blockIdent
%type <AbsBasilIR.procIdent> procIdent
%type <AbsBasilIR.beginList> beginList
%type <AbsBasilIR.endList> endList
%type <AbsBasilIR.beginRec> beginRec
%type <AbsBasilIR.endRec> endRec
%type <AbsBasilIR.lambdaSep> lambdaSep
%type <AbsBasilIR.str> str
%type <AbsBasilIR.integerHex> integerHex
%type <AbsBasilIR.integerDec> integerDec

%%

pModuleT : moduleT TOK_EOF { $1 };

pDecl_list : decl_list TOK_EOF { $1 };

pBlockIdent_list : blockIdent_list TOK_EOF { $1 };

pSemicolons : semicolons TOK_EOF { $1 };

pDecl : decl TOK_EOF { $1 };

pTypeT_list : typeT_list TOK_EOF { $1 };

pProcDef : procDef TOK_EOF { $1 };

pIntType : intType TOK_EOF { $1 };

pBoolType : boolType TOK_EOF { $1 };

pMapType : mapType TOK_EOF { $1 };

pBVType : bVType TOK_EOF { $1 };

pTypeT : typeT TOK_EOF { $1 };

pExpr_list : expr_list TOK_EOF { $1 };

pIntVal : intVal TOK_EOF { $1 };

pBVVal : bVVal TOK_EOF { $1 };

pEndian : endian TOK_EOF { $1 };

pAssignment : assignment TOK_EOF { $1 };

pStmt : stmt TOK_EOF { $1 };

pAssignment_list : assignment_list TOK_EOF { $1 };

pLocalVar : localVar TOK_EOF { $1 };

pGlobalVar : globalVar TOK_EOF { $1 };

pLocalVar_list : localVar_list TOK_EOF { $1 };

pVar : var TOK_EOF { $1 };

pNamedCallReturn : namedCallReturn TOK_EOF { $1 };

pNamedCallReturn_list : namedCallReturn_list TOK_EOF { $1 };

pLVars : lVars TOK_EOF { $1 };

pNamedCallArg : namedCallArg TOK_EOF { $1 };

pNamedCallArg_list : namedCallArg_list TOK_EOF { $1 };

pCallParams : callParams TOK_EOF { $1 };

pJump : jump TOK_EOF { $1 };

pLVar : lVar TOK_EOF { $1 };

pLVar_list : lVar_list TOK_EOF { $1 };

pBlock_list : block_list TOK_EOF { $1 };

pStmtWithAttrib : stmtWithAttrib TOK_EOF { $1 };

pStmtWithAttrib_list : stmtWithAttrib_list TOK_EOF { $1 };

pJumpWithAttrib : jumpWithAttrib TOK_EOF { $1 };

pBlock : block TOK_EOF { $1 };

pAttrKeyValue : attrKeyValue TOK_EOF { $1 };

pAttrKeyValue_list : attrKeyValue_list TOK_EOF { $1 };

pAttribSet : attribSet TOK_EOF { $1 };

pAttr_list : attr_list TOK_EOF { $1 };

pAttr : attr TOK_EOF { $1 };

pParams : params TOK_EOF { $1 };

pParams_list : params_list TOK_EOF { $1 };

pValue : value TOK_EOF { $1 };

pExpr : expr TOK_EOF { $1 };

pLambdaDef : lambdaDef TOK_EOF { $1 };

pBinOp : binOp TOK_EOF { $1 };

pUnOp : unOp TOK_EOF { $1 };

pEqOp : eqOp TOK_EOF { $1 };

pBVUnOp : bVUnOp TOK_EOF { $1 };

pBVBinOp : bVBinOp TOK_EOF { $1 };

pBVLogicalBinOp : bVLogicalBinOp TOK_EOF { $1 };

pIntBinOp : intBinOp TOK_EOF { $1 };

pIntLogicalBinOp : intLogicalBinOp TOK_EOF { $1 };

pBoolBinOp : boolBinOp TOK_EOF { $1 };

pRequireTok : requireTok TOK_EOF { $1 };

pEnsureTok : ensureTok TOK_EOF { $1 };

pFunSpec : funSpec TOK_EOF { $1 };

pProgSpec : progSpec TOK_EOF { $1 };

pFunSpec_list : funSpec_list TOK_EOF { $1 };

pProgSpec_list : progSpec_list TOK_EOF { $1 };

moduleT : decl_list { Module1 $1 }
  ;

decl_list : /* empty */ { []  }
  | decl SYMB1 decl_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

blockIdent_list : /* empty */ { []  }
  | blockIdent { (fun x -> [x]) $1 }
  | blockIdent SYMB2 blockIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

semicolons : /* empty */ { Semicolons_Empty  }
  | semicolons SYMB1 { Semicolons_Some $1 }
  ;

decl : KW_axiom attribSet expr { Decl_Axiom ($2, $3) }
  | KW_memory KW_shared globalIdent SYMB3 typeT { Decl_SharedMem ($3, $5) }
  | KW_memory globalIdent SYMB3 typeT { Decl_UnsharedMem ($2, $4) }
  | KW_var globalIdent SYMB3 typeT { Decl_Var ($2, $4) }
  | SYMB4 attribSet globalIdent SYMB3 SYMB5 typeT_list SYMB6 SYMB7 typeT { Decl_UninterpFun ($2, $3, $6, $9) }
  | SYMB8 attribSet globalIdent SYMB5 params_list SYMB6 SYMB7 typeT SYMB9 expr { Decl_Fun ($2, $3, $5, $8, $10) }
  | KW_prog KW_entry procIdent attribSet { Decl_ProgEmpty ($3, $4) }
  | KW_prog KW_entry procIdent attribSet beginList progSpec_list endList { Decl_ProgWithSpec ($3, $4, $5, $6, $7) }
  | KW_proc procIdent SYMB5 params_list SYMB6 SYMB7 SYMB5 params_list SYMB6 attribSet funSpec_list procDef { Decl_Proc ($2, $4, $8, $10, $11, $12) }
  ;

typeT_list : /* empty */ { []  }
  | typeT { (fun x -> [x]) $1 }
  | typeT SYMB2 typeT_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

procDef : /* empty */ { ProcDef_Empty  }
  | beginList block_list endList { ProcDef_Some ($1, $2, $3) }
  ;

intType : iNTTYPE { IntType1 $1 }
  ;

boolType : bOOLTYPE { BoolType1 $1 }
  ;

mapType : SYMB5 typeT SYMB7 typeT SYMB6 { MapType1 ($2, $4) }
  ;

bVType : bVTYPE { BVType1 $1 }
  ;

typeT : intType { TypeIntType $1 }
  | boolType { TypeBoolType $1 }
  | mapType { TypeMapType $1 }
  | bVType { TypeBVType $1 }
  ;

expr_list : /* empty */ { []  }
  | expr { (fun x -> [x]) $1 }
  | expr SYMB2 expr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intVal : integerHex { IntVal_Hex $1 }
  | integerDec { IntVal_Dec $1 }
  ;

bVVal : intVal SYMB3 bVType { BVVal1 ($1, $3) }
  ;

endian : KW_le { Endian_Little  }
  | KW_be { Endian_Big  }
  ;

assignment : lVar SYMB10 expr { Assignment1 ($1, $3) }
  ;

stmt : KW_nop { Stmt_Nop  }
  | assignment { Stmt_SingleAssign $1 }
  | SYMB5 assignment_list SYMB6 { Stmt_MultiAssign $2 }
  | lVar SYMB10 KW_load endian globalIdent expr intVal { Stmt_Load ($1, $4, $5, $6, $7) }
  | KW_store endian globalIdent expr expr intVal { Stmt_Store ($2, $3, $4, $5, $6) }
  | lVar SYMB10 KW_load endian var expr intVal { Stmt_Load_Var ($1, $4, $5, $6, $7) }
  | lVar SYMB10 KW_store endian var expr expr intVal { Stmt_Store_Var ($1, $4, $5, $6, $7, $8) }
  | lVars KW_call procIdent SYMB5 callParams SYMB6 { Stmt_DirectCall ($1, $3, $5) }
  | KW_indirect KW_call expr { Stmt_IndirectCall $3 }
  | KW_assume expr { Stmt_Assume $2 }
  | KW_guard expr { Stmt_Guard $2 }
  | KW_assert expr { Stmt_Assert $2 }
  ;

assignment_list : assignment { (fun x -> [x]) $1 }
  | assignment SYMB2 assignment_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

localVar : localIdent SYMB3 typeT { LocalVar1 ($1, $3) }
  ;

globalVar : globalIdent SYMB3 typeT { GlobalVar1 ($1, $3) }
  ;

localVar_list : localVar { (fun x -> [x]) $1 }
  | localVar SYMB2 localVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

var : localVar { VarLocalVar $1 }
  | globalVar { VarGlobalVar $1 }
  ;

namedCallReturn : lVar SYMB9 localIdent { NamedCallReturn1 ($1, $3) }
  ;

namedCallReturn_list : /* empty */ { []  }
  | namedCallReturn { (fun x -> [x]) $1 }
  | namedCallReturn SYMB2 namedCallReturn_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

lVars : /* empty */ { LVars_Empty  }
  | KW_var SYMB5 localVar_list SYMB6 SYMB10 { LVars_LocalList $3 }
  | SYMB5 lVar_list SYMB6 SYMB10 { LVars_List $2 }
  | SYMB5 namedCallReturn_list SYMB6 SYMB10 { NamedLVars_List $2 }
  ;

namedCallArg : localIdent SYMB9 expr { NamedCallArg1 ($1, $3) }
  ;

namedCallArg_list : /* empty */ { []  }
  | namedCallArg { (fun x -> [x]) $1 }
  | namedCallArg SYMB2 namedCallArg_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

callParams : expr_list { CallParams_Exprs $1 }
  | namedCallArg_list { CallParams_Named $1 }
  ;

jump : KW_goto SYMB5 blockIdent_list SYMB6 { Jump_GoTo $3 }
  | KW_unreachable { Jump_Unreachable  }
  | KW_return SYMB5 expr_list SYMB6 { Jump_Return $3 }
  | KW_return SYMB5 namedCallArg_list SYMB6 { Jump_ReturnNamedParams $3 }
  ;

lVar : KW_var localVar { LVar_Local $2 }
  | globalVar { LVar_Global $1 }
  ;

lVar_list : lVar { (fun x -> [x]) $1 }
  | lVar SYMB2 lVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block_list : /* empty */ { []  }
  | block { (fun x -> [x]) $1 }
  | block SYMB1 block_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

stmtWithAttrib : stmt attribSet { StmtWithAttrib1 ($1, $2) }
  ;

stmtWithAttrib_list : /* empty */ { []  }
  | stmtWithAttrib SYMB1 stmtWithAttrib_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

jumpWithAttrib : jump attribSet { JumpWithAttrib1 ($1, $2) }
  ;

block : KW_block blockIdent attribSet beginList stmtWithAttrib_list jumpWithAttrib SYMB1 endList { Block1 ($2, $3, $4, $5, $6, $8) }
  ;

attrKeyValue : bIdent SYMB9 attr { AttrKeyValue1 ($1, $3) }
  ;

attrKeyValue_list : /* empty */ { []  }
  | attrKeyValue { (fun x -> [x]) $1 }
  | attrKeyValue SYMB1 attrKeyValue_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

attribSet : beginRec attrKeyValue_list semicolons endRec { AttribSet_Some ($1, $2, $3, $4) }
  | /* empty */ { AttribSet_Empty  }
  ;

attr_list : /* empty */ { []  }
  | attr { (fun x -> [x]) $1 }
  | attr SYMB1 attr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

attr : beginRec attrKeyValue_list semicolons endRec { Attr_Map ($1, $2, $3, $4) }
  | beginList attr_list endList { Attr_List ($1, $2, $3) }
  | value { Attr_Lit $1 }
  | str { Attr_Str $1 }
  ;

params : localIdent SYMB3 typeT { Params1 ($1, $3) }
  ;

params_list : /* empty */ { []  }
  | params { (fun x -> [x]) $1 }
  | params SYMB2 params_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

value : bVVal { Value_BV $1 }
  | intVal { Value_Int $1 }
  | KW_true { Value_True  }
  | KW_false { Value_False  }
  ;

expr : value { Expr_Literal $1 }
  | localVar { Expr_Local $1 }
  | globalVar { Expr_Global $1 }
  | KW_forall lambdaDef { Expr_Forall $2 }
  | KW_exists lambdaDef { Expr_Exists $2 }
  | KW_old SYMB5 expr SYMB6 { Expr_Old $3 }
  | globalIdent SYMB5 expr_list SYMB6 { Expr_FunctionOp ($1, $3) }
  | binOp SYMB5 expr SYMB2 expr SYMB6 { Expr_Binary ($1, $3, $5) }
  | boolBinOp SYMB5 expr_list SYMB6 { Expr_Assoc ($1, $3) }
  | unOp SYMB5 expr SYMB6 { Expr_Unary ($1, $3) }
  | KW_zero_extend SYMB5 intVal SYMB2 expr SYMB6 { Expr_ZeroExtend ($3, $5) }
  | KW_sign_extend SYMB5 intVal SYMB2 expr SYMB6 { Expr_SignExtend ($3, $5) }
  | KW_extract SYMB5 intVal SYMB2 intVal SYMB2 expr SYMB6 { Expr_Extract ($3, $5, $7) }
  | KW_bvconcat SYMB5 expr_list SYMB6 { Expr_Concat $3 }
  ;

lambdaDef : SYMB5 localVar_list SYMB6 lambdaSep expr { LambdaDef1 ($2, $4, $5) }
  ;

binOp : bVBinOp { BinOpBVBinOp $1 }
  | bVLogicalBinOp { BinOpBVLogicalBinOp $1 }
  | boolBinOp { BinOpBoolBinOp $1 }
  | intLogicalBinOp { BinOpIntLogicalBinOp $1 }
  | intBinOp { BinOpIntBinOp $1 }
  | eqOp { BinOpEqOp $1 }
  ;

unOp : bVUnOp { UnOpBVUnOp $1 }
  | KW_boolnot { UnOp_boolnot  }
  | KW_intneg { UnOp_intneg  }
  | KW_booltobv1 { UnOp_booltobv1  }
  ;

eqOp : KW_eq { EqOp_eq  }
  | KW_neq { EqOp_neq  }
  ;

bVUnOp : KW_bvnot { BVUnOp_bvnot  }
  | KW_bvneg { BVUnOp_bvneg  }
  ;

bVBinOp : KW_bvand { BVBinOp_bvand  }
  | KW_bvor { BVBinOp_bvor  }
  | KW_bvadd { BVBinOp_bvadd  }
  | KW_bvmul { BVBinOp_bvmul  }
  | KW_bvudiv { BVBinOp_bvudiv  }
  | KW_bvurem { BVBinOp_bvurem  }
  | KW_bvshl { BVBinOp_bvshl  }
  | KW_bvlshr { BVBinOp_bvlshr  }
  | KW_bvnand { BVBinOp_bvnand  }
  | KW_bvnor { BVBinOp_bvnor  }
  | KW_bvxor { BVBinOp_bvxor  }
  | KW_bvxnor { BVBinOp_bvxnor  }
  | KW_bvcomp { BVBinOp_bvcomp  }
  | KW_bvsub { BVBinOp_bvsub  }
  | KW_bvsdiv { BVBinOp_bvsdiv  }
  | KW_bvsrem { BVBinOp_bvsrem  }
  | KW_bvsmod { BVBinOp_bvsmod  }
  | KW_bvashr { BVBinOp_bvashr  }
  ;

bVLogicalBinOp : KW_bvule { BVLogicalBinOp_bvule  }
  | KW_bvugt { BVLogicalBinOp_bvugt  }
  | KW_bvuge { BVLogicalBinOp_bvuge  }
  | KW_bvult { BVLogicalBinOp_bvult  }
  | KW_bvslt { BVLogicalBinOp_bvslt  }
  | KW_bvsle { BVLogicalBinOp_bvsle  }
  | KW_bvsgt { BVLogicalBinOp_bvsgt  }
  | KW_bvsge { BVLogicalBinOp_bvsge  }
  ;

intBinOp : KW_intadd { IntBinOp_intadd  }
  | KW_intmul { IntBinOp_intmul  }
  | KW_intsub { IntBinOp_intsub  }
  | KW_intdiv { IntBinOp_intdiv  }
  | KW_intmod { IntBinOp_intmod  }
  ;

intLogicalBinOp : KW_intlt { IntLogicalBinOp_intlt  }
  | KW_intle { IntLogicalBinOp_intle  }
  | KW_intgt { IntLogicalBinOp_intgt  }
  | KW_intge { IntLogicalBinOp_intge  }
  ;

boolBinOp : KW_booland { BoolBinOp_booland  }
  | KW_boolor { BoolBinOp_boolor  }
  | KW_boolimplies { BoolBinOp_boolimplies  }
  ;

requireTok : KW_require { RequireTok_require  }
  | KW_requires { RequireTok_requires  }
  ;

ensureTok : KW_ensure { EnsureTok_ensure  }
  | KW_ensures { EnsureTok_ensures  }
  ;

funSpec : requireTok expr { FunSpec_Require ($1, $2) }
  | ensureTok expr { FunSpec_Ensure ($1, $2) }
  | KW_invariant blockIdent expr { FunSpec_Invariant ($2, $3) }
  ;

progSpec : KW_rely expr { ProgSpec_Rely $2 }
  | KW_guarantee expr { ProgSpec_Guarantee $2 }
  ;

funSpec_list : /* empty */ { []  }
  | funSpec SYMB1 funSpec_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

progSpec_list : /* empty */ { []  }
  | progSpec SYMB1 progSpec_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

bVTYPE : TOK_BVTYPE { BVTYPE ($1)};
iNTTYPE : TOK_INTTYPE { INTTYPE ($1)};
bOOLTYPE : TOK_BOOLTYPE { BOOLTYPE ($1)};
bIdent : TOK_BIdent { BIdent ($1)};
localIdent : TOK_LocalIdent { LocalIdent ($1)};
globalIdent : TOK_GlobalIdent { GlobalIdent ($1)};
blockIdent : TOK_BlockIdent { BlockIdent ($1)};
procIdent : TOK_ProcIdent { ProcIdent ($1)};
beginList : TOK_BeginList { BeginList ($1)};
endList : TOK_EndList { EndList ($1)};
beginRec : TOK_BeginRec { BeginRec ($1)};
endRec : TOK_EndRec { EndRec ($1)};
lambdaSep : TOK_LambdaSep { LambdaSep ($1)};
str : TOK_Str { Str ($1)};
integerHex : TOK_IntegerHex { IntegerHex ($1)};
integerDec : TOK_IntegerDec { IntegerDec ($1)};

